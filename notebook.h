#pragma once  /// защита от многократного вызова
#include <string>   ///Библиотека для использования типа string(строка), а не char* (массив символов)
#include <iostream> ///Библиотека потока ввода( cin ) и потока вывода( cout )

///Лабораторная работа №1 Создание класса, методов print, get и set, конструкторов без параметров, с параметрами, копирования

class Notebook  ///Считается этикой писать классы с большой буквы, а просто переменные и функции с маленькой
{
protected:  ///используем протект , а не private, так как в дальнейшем мы сможем давать доступ для наследующих классов к полям
    float model;        ///используем для определения модели число с плавающей точкой, для того что бы могли до точки указывать версию продукта, а после точки номер переработки версии
    std::string memory;      ///хранит название используемой памяти, например DDR3
    int CPU;            ///хранит размер ранее названной памяти

public:
    Notebook();             ///конструктор без параметров
    Notebook( float const * const model );  ///конструктор с 1 параметром , для аргумента: float const - делаем неизменяемым значение, хранящееся в переменной   , * const -делаем неизменяемым значение указателя
    Notebook( std::string const * const memory ); ///конструктор с 1 параметром , для аргумента: string const - делаем неизменяемым значение, хранящееся в переменной   , * const -делаем неизменяемым значение указателя
    Notebook( int const CPU );    ///конструктор с 1 параметром , для аргумента: int const - делаем неизменяемым значение, хранящееся в переменной     , указатель не используем, так как выйгрыша в пямяти не будет
    Notebook( float const * const model, std::string const * const memory, int const CPU );    ///конструктор с параметрами для всех полей
    Notebook( Notebook const * const notebook );   ///конструктор копирования, по-сути, конструктор с указателем на иной объект в качестве параметра.

    void print() const;      ///метод print будет выводить полностью имеющуюсю информацию об объекте класса, модификатор const после метода говорит о том, что внутри не могут меняться значения полей класса

    void setModel( float const * const model );     ///метод для изменения значения поля model  , для аргумента: float const - делаем неизменяемым значение, хранящееся в переменной   , * const -делаем неизменяемым значение указателя
    void setMemory( std::string const * const memory );   ///метод для изменения значения поля memory , для аргумента: string const - делаем неизменяемым значение, хранящееся в переменной  , * const -делаем неизменяемым значение указателя
    void setCPU( int const CPU );                    ///метод для изменения значения поля CPU    , для аргумента: int const - делаем неизменяемым значение, хранящееся в переменной     , указатель не используем, так как выйгрыша в пямяти не будет

    const float& getModel() const;     ///метод для получения значения поля model  , модификатор const после метода говорит о том, что внутри не могут меняться значения полей класса
    const std::string& getMemory() const;   ///метод для получения значения поля memory , модификатор const после метода говорит о том, что внутри не могут меняться значения полей класса
    const int& getCPU() const;         ///метод для получения значения поля CPU    , модификатор const после метода говорит о том, что внутри не могут меняться значения полей класса

///Лабораторная работа №2 Перегрузка операторов

    Notebook& operator ++();    ///Инкремент префиксный (++notebook)        не объявляем константным методом, т.к. он меняет поля объекта
    Notebook operator ++(int);  ///Инкремент постфиксный (notebook++)       не объявляем константным методом, т.к. он меняет поля объекта
    Notebook& operator --();    ///Декремент префиксный (--notebook)        не объявляем константным методом, т.к. он меняет поля объекта
    Notebook operator --(int);  ///Декремент постфиксный (notebook--)       не объявляем константным методом, т.к. он меняет поля объекта

    void operator =( Notebook const * const notebook );         ///оператор присваивания    ничего не возвращает        не объявляем константным методом, т.к. он меняет поля объекта

    bool operator ==( Notebook const * const notebook ) const;  ///оператор равенства       возвращает логический ответ true(да(1)) или false(нет(0))   объявляем константным методом, т.к. он не меняет полей объекта
    bool operator !=( Notebook const * const notebook ) const;  ///оператор неравенства     возвращает логический ответ true(да(1)) или false(нет(0))   объявляем константным методом, т.к. он не меняет полей объекта
    bool operator >( Notebook const * const notebook ) const;   ///оператор строго больше   возвращает логический ответ true(да(1)) или false(нет(0))   объявляем константным методом, т.к. он не меняет полей объекта
    bool operator <( Notebook const * const notebook ) const;   ///оператор строго меньше   возвращает логический ответ true(да(1)) или false(нет(0))   объявляем константным методом, т.к. он не меняет полей объекта
    bool operator >=( Notebook const * const notebook ) const;  ///оператор больше-равно    возвращает логический ответ true(да(1)) или false(нет(0))   объявляем константным методом, т.к. он не меняет полей объекта
    bool operator <=( Notebook const * const notebook ) const;  ///оператор меньше-равно    возвращает логический ответ true(да(1)) или false(нет(0))   объявляем константным методом, т.к. он не меняет полей объекта

    friend std::ostream& operator << (std::ostream &out, Notebook const * const notebook);
    friend std::istream& operator >> (std::istream &in, Notebook * notebook);
};
